# -*- coding: utf-8 -*-
"""Introduccion_a_Python_(1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1um-CqM-UzvhSweVqMcjJXZ65cVhZ_Mpg

# Regresión lineal múltiple en python
Seminario de Estadística 2024-2

# Introducción a Python y al Análisis Descriptivo.



1.   Comenzamos con lo más importante, poner gatitos y perritos, para eso nos dirigimos a Herramientas > Configuración > Varios > Modo Gatito|Modo Corgi
2.   Una vez visto lo importante, lo primero es comentar algunas diferencias entre R y Python.

      *   De entrada, los DataFrames y los vectores no existen en Python base, como sí ocurren en R, por lo que, si quisiéramos trabajar con ellos, necesitaríamos paqueterías adicionales lista.
      *   La discusión típica, la indexación, en R sabemos que el primer índice de un objeto es 1, sin embargo, el primer índice de un objeto en Pyhton es el 0.
      *   La manera de realizar operaciones lógicas, en R utilizamos los símbolos & y |, sin embargo, en Python estos operadores realizan operaciones diferentes, por lo que se utilizan en su lugar palabras reservadas "and" y "or".

# Tipos de dato.

En Python, al igual que en R tenemos una cantidad diversa de datos, los cuales vamos a conocer de manera rápida a continuación
"""

# Comentarios en Python: se usan con #
"""

O bien de esta otra forma, que es muy practica para comentarios de varias lineas.


"""

# --- Tipos de Datos en Python ---

# Tipo String (cadenas de texto)
# Se pueden usar comillas simples, dobles o triples
texto = "Hola Mundo"
comentario_multilinea = """Esto también es un comentario en varias líneas."""

print(comentario_multilinea)

# Tipo Entero (int): números sin decimales
num_entero = 5

# Tipo Flotante (float): números con decimales
num_float1 = 5.5
num_float2 = 4.0

# Ver el tipo de dato con type()
print(type(num_float1))

# --- Listas: el iterable básico en Python ---
# Se definen con corchetes []
lista_vacia = []
lista_mixta = [1, "Hola", 3.6, False, [1, 2]]

"""
Sintaxis en R de un for
for ( ) {
}
"""

# Recorrer una lista e imprimir el tipo de cada elemento
for elemento in lista_mixta:
    print(f"{elemento} es del tipo: {type(elemento)} y el indice es {lista_mixta.index(elemento)}")

# --- Notas sobre identación ---
# Python usa espacios o tabuladores para estructurar el código.
# Se recomienda usar 4 espacios por nivel de identación y no mezclarlos con tabuladores.

"""Debemos conocer el cambio siguiente con respecto a las estructuras de control (if, for y while)

Y es que, mientras en R utilizamos llaves para delimitar, en Python sólo vamos a identar después de dos puntos ":"

Es recomendable usar los numeros de linea, para identificar de manera más facil los errores.

Una
"""

#Para importar librerías, nosotros primero tenemos que instalarlas
#En colab, pandas y varias paqueterías ya se encuentran descargadas

#Si no lo está, usamos !pip install "paquetería"
import pandas as pd

# --- Creación de un DataFrame de ejemplo ---
datos = {
    "Nombre": ["Ana", "Luis", "Carlos", "Marta", "Sofía"],
    "Edad": [25, 30, 35, 40, 28],
    "Salario": [50000, 60000, 70000, 80000, 55000],
    "Departamento": ["IT", "Finanzas", "RRHH", "Ventas", "IT"]
}

df = pd.DataFrame(datos)

# Mostrar el DataFrame
print("DataFrame:")
print(df)

# --- Uso de .iloc (indexación por posición) ---
print("Fila en la posición 2 (Carlos):")
print(df.iloc[2], "\n")  # Selecciona la tercera fila (índice 2)

print("Filas 1 a 3 y columnas 0 y 2:")
print(df.iloc[1:4, [0, 2]], "\n")  # Selecciona filas 1 a 3 y columnas "Nombre" y "Salario"

# --- Uso de .loc (indexación por etiqueta) ---
print("Fila con índice 3 (Marta):")
print(df.loc[3], "\n")  # Selecciona la fila con índice 3

print("Seleccionar nombres y salarios de empleados de IT:")
print(df.loc[df["Departamento"] == "IT", ["Nombre", "Salario"]], "\n")  # Filtrar por departamento

# --- Modificación de datos con .loc ---
df.loc[df["Nombre"] == "Ana", "Salario"] = 52000  # Cambiar salario de Ana
print("Nuevo DataFrame con salario actualizado de Ana:")
print(df)

"""Si bien existen muchos otros tipos de datos y metodos en Python, no podemos abordar en exceso estos temas, pues escapan del alcance del curso, pero podemos comenzar con lo que realmente nos interesa

# Ejemplo práctico
"""

!pip install faraway

import pandas as pd # manipulación de tablas
import numpy as np  # calculo numeríco y análisis de datos
import matplotlib.pyplot as plt # generar plot
import statsmodels.api as sm
import statsmodels.formula.api as smf
import seaborn as sns  #permite generar graficos estadisticos
from scipy import stats
import faraway.utils
import statsmodels.stats.diagnostic as sms
from statsmodels.stats.stattools import jarque_bera

# La sentencia import seria analoga al la instrucción library en R, en python se define un alias a dicha libreria y asi se mandará a llamar

# Hecho lo anterior, lo primero que vamos a hacer, es leer un dataframe
# ¿Como sé carga un archivo a google colab?
#Como ya se encuentra nuestro archivo cargado, podemos continuar
df = pd.read_csv("datos.csv")
#df = pd.read_csv("/content/datos.csv")
df.head()
#¿Pero cómo hacemos para no cargar siempre?

#Una de las ventajas es conectar Drive con colab y tenemos
from google.colab import drive
drive.mount('/content/gdrive')

#Ahora podemos utilizar la carpeta gdrive para acceder a archivos
df = pd.read_csv("/content/gdrive/MyDrive/datos.csv")

#Empezamos presentando algunos de nuestros datos, de manera descriptivo
df = df.rename(columns = {"x1": "Edad"})
df.head()

#Ahora empezamos con nuestro análisis descriptivo, con lo siguiente
df.describe()

"""
La función describe se aplica al data frame df,
algo similar generaria la funcion summary(df) en R
"""

"""Podemos aplicar funciones a tablas completas o en su defecto aplicarlas a algunas columnas"""

df["Edad"].describe()

"""# Aplicar alguna metrica particular."""

# Aplicar las metricas de forma particular
print(df["Edad"].min())
print(df["Edad"].max())
print(df["Edad"].mean())
print(df['Tratamiento'].count())

# Y como siempre, lo primero que podemos hacer, es un resumen
funciones = ["min", "median", "mean", "std", "max"]
df.groupby("Tratamiento").agg({"Edad":funciones}).round(1)
# Noten que en general, se hacer una concatenación de funciones, en primer lugar se agrupa por la variable "Tratamiento"
# Posteriormente con la función agg aplica una función o más (como en este caso), por ultimo los resultados seran redondeados
# a un solo decimal.

#Podemos ahora agrupar por tratamiento para realizar nuestra descripción
df.groupby("Tratamiento").agg({"y": "describe"}).round(1)

# Pero también podemos realizar gráficas descriptivas
sns.boxplot(x = "Tratamiento", y ="y", data = df)

# Pero también podemos realizar gráficas descriptivas
sns.scatterplot(x = "Edad", y ="y", data = df, hue="Tratamiento")

# Este grafico es muy interesante el analogo a este grafico se encontraria en la función ggpairs en R
#darkgrid: Fondo claro con cuadrícula oscura (este es el estilo predeterminado de Seaborn).
#whitegrid: Fondo blanco con cuadrícula.
#dark: Fondo oscuro sin cuadrícula.
#white: Fondo completamente blanco, sin cuadrícula.
sns.set(style="whitegrid")
#sns.pairplot(df)
sns.pairplot(df,hue = 'Tratamiento', diag_kind='hist')

"""# Observaciones:
Algo que pudimos notar de estos ejemplos es que en general no aplicamos funciones a las variables, esto se debe a que, ya que Python es en parte un lenguaje orientado a objetos, lo que suele tener son métodos de cada uno de los objetos que se instancean, en lugar de tener funciones (como es el caso de R)

## Ajuste del modelo

Antes poder continuar con nuestro modelado, hay algo más de lo que debemos hablar, en Python, a diferencia de R, no existen las variables de tipo factor, por lo que, algo que ya hemos comentado, podríamos tener que añadir una variable dicotómica para cada nivel de las variables categóricas, en este caso, tenemos los niveles $A,B,C$, por lo que deberíamos definir
$\delta_A(Trat)=1 \text{ si Trat = A y } \delta_A(Trat)=0 \text{ si Trat }\neq\text{A}$, y haríamos lo mismo para $B$ y $C$
"""

#Para crear las variables tenemos diferentes métodos

# 1 con un ciclo para cada valor
X_A = []

for i in df["Tratamiento"]:
  if i == "A":
    X_A.append(1)
  else:
    X_A.append(0)

#Y de aquí asignamos la columna
df["X_A"]=X_A

df.head()

#Ahora la eliminamos para reiniciar
df = df.drop("X_A", axis=1)
df.head()

#Ahora lo podemos hacer con la función apply, similar a lo que conocemos
df["X_A"] = df["Tratamiento"].apply(lambda x: 1 if x=="A" else 0)
df.head()

#Eliminamos para reiniciar
df = df.drop("X_A", axis=1)
df.head()

#Finalmente, la forma más eficiente
#donde no es necesario rellenar las columnas de una en una
df_rlm = pd.get_dummies(df, columns=["Tratamiento"])
df_rlm.head()

df_rlm = df_rlm.astype(int)
df_rlm.head()

df.head()

#En este momento utilizaremos la paquetería smf para el ajuste
fit1 = smf.ols("y~Edad*Tratamiento", df).fit() #Para el ajuste usamos df
fit1.sumary()

print(fit1.summary())

#Pero es equivalente a utilizar las variables dicotómicas
modelo =smf.ols("y~Edad+Tratamiento_B+Tratamiento_C+Edad:Tratamiento_B+Edad:Tratamiento_C", df_rlm)
fit2 = modelo.fit()
print(fit2.summary())

#Vamos a graficar nuestras estimaciones puntuales

#Las vamos a obtener de los parámetros del modelo
print(fit2.params)

#Definimos las funciones que vamos a utilizar
def graficar_A(Edad):
  return fit2.params[0]+fit2.params[1]*Edad

def graficar_B(Edad):
  return fit2.params[0]+fit2.params[1]*Edad+fit2.params[2]+fit2.params[4]*Edad

def graficar_C(Edad):
  return fit2.params[0]+fit2.params[1]*Edad+fit2.params[3]+fit2.params[5]*Edad

#Ahora graficamos la información
x=range(15,70)

plt.plot(x, [graficar_A(i) for i in x],label="Curva Tratamiento A")
plt.scatter(df[df['Tratamiento']=="A"].Edad, df[df['Tratamiento']=="A"].y)

plt.plot(x, [graficar_B(i) for i in x],label="Curva Tratamiento B")
plt.scatter(df[df['Tratamiento']=="B"].Edad, df[df['Tratamiento']=="B"].y)

plt.plot(x, [graficar_C(i) for i in x], label="Curva Tratamiento C")
plt.scatter(df[df['Tratamiento']=="C"].Edad, df[df['Tratamiento']=="C"].y)

# Añadir título y etiquetas de ejes
plt.title("Gráfica por Tratamiento")
plt.xlabel("Edad")
plt.ylabel("Variable y")

# Mostrar la leyenda
plt.legend()

# Mostrar la gráfica
plt.show()